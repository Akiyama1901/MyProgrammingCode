词法分析
为了把程序从一种语言翻译成另一种语言，编译器必须首先把程序分解并搞清相应的结构和含义，然后再用不同的方式把它们组合起来。编译器的前端负责分析，后端负责组合。
分析的类别
分析包含3类：
词法分析：将输入分解成单独的字或记号；
语法分析：分析程序中短语的结构；
语义分析：分析程序的含义。
词法分析器接收字符流，生成一系列的名字、关键字和标点符号，并舍弃了记号之间的空白符和注释。
那些随机出现的空白符和注释将分析过程复杂化了，这也是将词法分析单独分离出去的主要原因。
词法分析并不是很复杂，但是需要使用形式化的方法和工具来实现，类似的方法对于学习分析是很有好处的，类似的工具还可以应用在编译器外的其他地方。
词法记号
词法记号可以看做是编程语言语法单元的一系列字符。编程语言的词法记号分为有限的几种记号类型。
例如，有一些典型的编程语言的记号类型为：
类型	示例
ID	foo、n14、last
NUM	73 000 515
REAL	66.1 .5 10 1e67 5.5e-10
IF	if
COMMA	,
LPAREN	(
RPAREN	)
IF，VOID， RETURN 等由字母表中的字符组成的记号叫做“保留字”， 在大多数语言中， 它们不能被看成标识符。
下面是一组非记号的例子：
说明	示例
注释	/*try again*/
预处理命令	include<stdio.h>
预处理命令	#define NUMS 5， 6
宏	NUMS
空格、跳格和回车	 
因语言的功能不够强大，所以需要一个宏预处理，这个预处理对原始的字符流操作，并生成一个适合于词法分析器的新的字符流。
可以把宏处理和词法分析合二为一。
考虑如下的程序段：
  [plaintext]
float match 0(char*s)/*find azero*/
(if(!strncmp(s，“0.0”，3))
    return 0.；
词法分析器将返回如下数据流：
  [plaintext]
FLOAT ID(match 0) LPAREN CHAR STAR ID(s) RPAREN
LB RACE IF LPAREN BANG ID(strncmp) LPAREN ID(s)
COMMA STRING(0.0) COMMA NUM(3) RPAREN RPAREN
RETURN REAL(0.0) SEMIR BRACEE OF
其中显示了每个记号的记号类型。它们中的一些记号，比如标识符和文字，本身都含有语义信息，需要在记号类型中给出附加的信息。
如何描述编程语言的词法规则呢?词法分析器可以用什么样的语言编写呢?
可以用英文来描述语言的词法记号。
标识符
以下是在C或Java中对标识符的描述：
标识符是由一系列的字母和数字组成的，必须以一个字母开头。下划线计为一个字母。标识符区分大小写，其中不能包括空格、跳格、回车和注释，除非它们列为单独的一类记号。但有时需要一些空格来分隔相邻的标识符、关键字和常量。
有很多用于实现词法分析器的语言，但是常用正则表达式来定义词法记号，用确定有限自动机来实现词法分析器并用某种机制来连接它们。
由此来实现一个简洁、具有可读性的词法分析器。
正则表达式
程序语言可以认为是一个字符串集，字符串是一个有限的符号集。符号本身就是有限的字母。
Pascal语言就是一个字符串集， 这些字符串组成了合法的Pascal程序；
素数语言是一个十进制数字的字符串集，它们代表素数；C语言中的保留字也是一个字符串集，它们不能被看做是C语言的标识符。Pascal语言和素数语言是无限集， 而Ｃ语言中的保留字则是一个有限集。在上述情况中， 字母表均以A SCI字符集加以表示。
若用这种方式谈论语言，那么字符串就失去了本身的意义，我们只是试图将每个字符串都归类到语言中。
为了用有限的描述来详细说明这些(很可能是无限的)语言，这里将使用称为正则表达式的符号表示法。
每个正则表达式代表一个字符串集。
基本概念
符号：对于语言字母表中的每个符号a，正则表达式a表示仅包含字符串a的语言。
或：对于给定的两个正则表达式M和N，用操作符或竖线 (|) 连接为一个新的正则表达式：M丨N。
若一个字符串属于语言Ｍ或语言N、那么此串也属于语言 M丨N。
因此， 语言 a|b 包含两个字符串a和b。
并：对于给定的两个正则表达式M和N，可以利用并操作符(·)将其连接为新的正则表达式M·N，设α是语言Ｍ的字符串，β是语言N的字符串，若一个字符串是α与β的并，那么这个字符串属于语言M·N：因此，正则表达式 (a|b)·a 定义包含两个字符串aa和ba的语言。
ε(epsilon)：正则表达式：代表了一个只包含空串的语言。因此 (a·b)|ε 表示语言{““，”ab”}。
重复：对于正则表达式M，其Kleene闭包是 M*。若一个字符串为空或者它是M中所有字符串经过并操作所得到的结果，那么它就属于 M*。
因此， ((a|b)·a)* 代表无限集 {““， “a a”， “ba”，”aaaa”， “baaa”，”aaba”， “baba”，”aaaaaa”，…}。
通过使用这些符号， 以及或、并、8和Kleene闭包， 就能够规定和编程语言的词法记号相对应的ASCII字符集。